/**
 * @fileoverview logger.info(`template string not allowed`)
 * @author Parin
 * @copyright 2016 Parin. All rights reserved.
 * See LICENSE file in root directory for full license.
 */
"use strict";
//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------
var print = function() {
	// console.log(arguments);
}

function log(context) {

	var astUtil = require(__dirname + '/../astUtil');
	return {
		CallExpression: function(node) {

			var sourceCode = context.getSourceCode();
			var nodeSource = sourceCode.getText(node);
			var caller = astUtil.getCaller(node);
			var method = astUtil.getMethodName(node)

			var notAllowedArgType = ['TemplateLiteral'];
			var logMethods = ['info', 'error', 'log', 'warn', 'debug'];

			// variable or object or string
			var onlyOneArgument = ['ObjectExpression', 'Identifier', 'Literal'];

			var callers = ['Identifier', 'MemberExpression'];

			var twoArguments = {
				first: ['ObjectExpression'],
				second: ['Identifier', 'Literal']
			};

			// if (logMethods.indexOf(method) !== -1 && caller && ['Identifier', 'MemberExpression'].indexOf(caller.type) === -1) {
			// 	console.log('*'.repeat(100));
			// 	console.log(nodeSource);
			// 	console.log("method",method);
			// 	console.log("caller", caller);
			// 	console.log('*'.repeat(100));
			// }
			// print('caller',caller,callers.indexOf(caller) !== -1);
			// callers.indexOf(caller) !== -1 && 

			if (caller && callers.indexOf(caller.type) !== -1 && logMethods.indexOf(method) !== -1) {

				print("*".repeat(123));
				print("file", context.getFilename());
				print("source", nodeSource);
				print("node", node);
				print("total arguments : ", node.arguments.length);
				print("arguments : ", node.arguments);
				print("caller", caller);
				print("method", method);
				print("*".repeat(123));

				if (node.arguments.length > 2) {
					// dhiskiyaooon !!!!
					return report(node, "More than 2 arguments to logger");
				}

				for (var i = 0; i < node.arguments.length; i++) {
					var arg = node.arguments[i];
					print("*".repeat(100));
					print(arg);
					if (notAllowedArgType.indexOf(arg.type) !== -1) {
						// specially 'TemplateLiteral'
						report(node, "'TemplateLiteral' not allowed as argument in logger.");
						break;
					}
					print("*".repeat(100));
				}


				// if two arguments then first must be an ObjectExpression and second must be Literal
				if (node.arguments.length === 2) {

					// first argument must be an 'ObjectExpression'
					if (twoArguments.first.indexOf(node.arguments[0].type) === -1) {
						report(node, "only 'ObjectExpression' is allowed as first argument in logger if 2 arguments.")
					}

					// second argument must be as 'Literal' or 'Identifier'
					if (twoArguments.second.indexOf(node.arguments[1].type) === -1) {
						report(node, "only 'Literal' is allowed as second argument in logger if 2 arguments.");
					}

				}

				if (node.arguments.length === 1) {

					// only 1 argument that has to be either a Literal or an ObjectExpression
					if (onlyOneArgument.indexOf(node.arguments[0].type) === -1) {
						report(node, "only 'Literal' or 'ObjectExpression' is allowed in arguments in logger if only 1 argument.");
					}

				}

			}

			function report(node, msg) {
				context.report({
					node: node,
					message: msg
				});
			}
		}
	};
};

module.exports = log;
module.exports.schema = [];
